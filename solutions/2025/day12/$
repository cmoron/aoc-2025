use std::fmt;

fn main() {
    let input = include_str!("../input.txt");

    let start = std::time::Instant::now();
    println!("Part 1: {}", part1(input));
    println!("Time: {:.4}ms", start.elapsed().as_secs_f64() * 1000.0);

    let start = std::time::Instant::now();
    println!("Part 2: {}", part2(input));
    println!("Time: {:.4}ms", start.elapsed().as_secs_f64() * 1000.0);
}

#[derive(Debug)]
struct Present {
    id: u8,
    shape: u16,
}

impl fmt::Display for Present {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:\n", self.id)?;
        for row in self.shape.iter() {
            for &cell in row.iter() {
                let symbol = if cell { '#' } else { '.' };
                write!(f, "{}", symbol)?;
            }
            writeln!(f)?;
        }
        Ok(())
    }
}

fn part1(input: &str) -> usize {
    let id = 0;
    let shape = vec![
        vec![true, true, true],
        vec![true, false, true],
        vec![true, true, true],
    ];
    let _present = Present { id, shape: shape };

    println!("{}", _present);

    0
}

fn part2(input: &str) -> usize {
    0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_part1_example() {
        let example_input = include_str!("../example.txt");
        assert_eq!(part1(example_input), 2);
    }
}
